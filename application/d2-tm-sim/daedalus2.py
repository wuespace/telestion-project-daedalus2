"""
MAVLink protocol implementation (auto-generated by mavgen.py)

Generated from: ('daedalus.xml',)

Note: this file has been auto-generated. DO NOT EDIT
"""
import hashlib
import json
import logging
import os
import struct
import sys
import time
from builtins import object, range
from typing import Any, Callable, Dict, Iterable, List, Mapping, Optional, Sequence, Tuple, Type, Union, cast

WIRE_PROTOCOL_VERSION = "2.0"
DIALECT = "daedalus2"

PROTOCOL_MARKER_V1 = 0xFE
PROTOCOL_MARKER_V2 = 0xFD
HEADER_LEN_V1 = 6
HEADER_LEN_V2 = 10

MAVLINK_SIGNATURE_BLOCK_LEN = 13

MAVLINK_IFLAG_SIGNED = 0x01

if sys.version_info[0] == 2:
    logging.basicConfig()

logger = logging.getLogger(__name__)

# allow MAV_IGNORE_CRC=1 to ignore CRC, allowing some
# corrupted msgs to be seen
MAVLINK_IGNORE_CRC = os.environ.get("MAV_IGNORE_CRC", 0)

# some base types from mavlink_types.h
MAVLINK_TYPE_CHAR = 0
MAVLINK_TYPE_UINT8_T = 1
MAVLINK_TYPE_INT8_T = 2
MAVLINK_TYPE_UINT16_T = 3
MAVLINK_TYPE_INT16_T = 4
MAVLINK_TYPE_UINT32_T = 5
MAVLINK_TYPE_INT32_T = 6
MAVLINK_TYPE_UINT64_T = 7
MAVLINK_TYPE_INT64_T = 8
MAVLINK_TYPE_FLOAT = 9
MAVLINK_TYPE_DOUBLE = 10


class x25crc(object):
    """CRC-16/MCRF4XX - based on checksum.h from mavlink library"""

    def __init__(self, buf: Optional[Sequence[int]] = None) -> None:
        self.crc = 0xFFFF
        if buf is not None:
            self.accumulate(buf)

    def accumulate(self, buf: Sequence[int]) -> None:
        """add in some more bytes (it also accepts python2 strings)"""
        if sys.version_info[0] == 2 and type(buf) is str:
            buf = bytearray(buf)

        accum = self.crc
        for b in buf:
            tmp = b ^ (accum & 0xFF)
            tmp = (tmp ^ (tmp << 4)) & 0xFF
            accum = (accum >> 8) ^ (tmp << 8) ^ (tmp << 3) ^ (tmp >> 4)
        self.crc = accum


class MAVLink_header(object):
    """MAVLink message header"""

    def __init__(self, msgId: int, incompat_flags: int = 0, compat_flags: int = 0, mlen: int = 0, seq: int = 0, srcSystem: int = 0, srcComponent: int = 0) -> None:
        self.mlen = mlen
        self.seq = seq
        self.srcSystem = srcSystem
        self.srcComponent = srcComponent
        self.msgId = msgId
        self.incompat_flags = incompat_flags
        self.compat_flags = compat_flags

    def pack(self, force_mavlink1: bool = False) -> bytes:
        if float(WIRE_PROTOCOL_VERSION) == 2.0 and not force_mavlink1:
            return struct.pack(
                "<BBBBBBBHB",
                253,
                self.mlen,
                self.incompat_flags,
                self.compat_flags,
                self.seq,
                self.srcSystem,
                self.srcComponent,
                self.msgId & 0xFFFF,
                self.msgId >> 16,
            )
        return struct.pack(
            "<BBBBBB",
            PROTOCOL_MARKER_V1,
            self.mlen,
            self.seq,
            self.srcSystem,
            self.srcComponent,
            self.msgId,
        )


class MAVLink_message(object):
    """base MAVLink message class"""

    id = 0
    msgname = ""
    fieldnames: List[str] = []
    ordered_fieldnames: List[str] = []
    fieldtypes: List[str] = []
    fielddisplays_by_name: Dict[str, str] = {}
    fieldenums_by_name: Dict[str, str] = {}
    fieldunits_by_name: Dict[str, str] = {}
    native_format = bytearray(b"")
    orders: List[int] = []
    lengths: List[int] = []
    array_lengths: List[int] = []
    crc_extra = 0
    unpacker = struct.Struct("")
    instance_field: Optional[str] = None
    instance_offset = -1

    def __init__(self, msgId: int, name: str) -> None:
        self._header = MAVLink_header(msgId)
        self._payload: Optional[bytes] = None
        self._msgbuf = bytearray(b"")
        self._crc: Optional[int] = None
        self._fieldnames: List[str] = []
        self._type = name
        self._signed = False
        self._link_id: Optional[int] = None
        self._instances: Optional[Dict[str, str]] = None
        self._instance_field: Optional[str] = None

    def format_attr(self, field: str) -> Union[str, float, int]:
        """override field getter"""
        raw_attr = cast(Union[bytes, float, int], getattr(self, field))
        if isinstance(raw_attr, bytes):
            if sys.version_info[0] == 2:
                return raw_attr.rstrip(b"\x00")
            return raw_attr.decode(errors="backslashreplace").rstrip("\x00")
        return raw_attr

    def get_msgbuf(self) -> bytearray:
        return self._msgbuf

    def get_header(self) -> MAVLink_header:
        return self._header

    def get_payload(self) -> Optional[bytes]:
        return self._payload

    def get_crc(self) -> Optional[int]:
        return self._crc

    def get_fieldnames(self) -> List[str]:
        return self._fieldnames

    def get_type(self) -> str:
        return self._type

    def get_msgId(self) -> int:
        return self._header.msgId

    def get_srcSystem(self) -> int:
        return self._header.srcSystem

    def get_srcComponent(self) -> int:
        return self._header.srcComponent

    def get_seq(self) -> int:
        return self._header.seq

    def get_signed(self) -> bool:
        return self._signed

    def get_link_id(self) -> Optional[int]:
        return self._link_id

    def __str__(self) -> str:
        ret = "%s {" % self._type
        for a in self._fieldnames:
            v = self.format_attr(a)
            ret += "%s : %s, " % (a, v)
        ret = ret[0:-2] + "}"
        return ret

    def __ne__(self, other: object) -> bool:
        return not self.__eq__(other)

    def __eq__(self, other: object) -> bool:
        if other is None:
            return False

        if not isinstance(other, MAVLink_message):
            return False

        if self.get_type() != other.get_type():
            return False

        if self.get_crc() != other.get_crc():
            return False

        if self.get_seq() != other.get_seq():
            return False

        if self.get_srcSystem() != other.get_srcSystem():
            return False

        if self.get_srcComponent() != other.get_srcComponent():
            return False

        for a in self._fieldnames:
            if self.format_attr(a) != other.format_attr(a):
                return False

        return True

    def to_dict(self) -> Dict[str, Union[str, float, int]]:
        d: Dict[str, Union[str, float, int]] = {}
        d["mavpackettype"] = self._type
        for a in self._fieldnames:
            d[a] = self.format_attr(a)
        return d

    def to_json(self) -> str:
        return json.dumps(self.to_dict())

    def sign_packet(self, mav: "MAVLink") -> None:
        assert mav.signing.secret_key is not None

        h = hashlib.new("sha256")
        self._msgbuf += struct.pack("<BQ", mav.signing.link_id, mav.signing.timestamp)[:7]
        h.update(mav.signing.secret_key)
        h.update(self._msgbuf)
        sig = h.digest()[:6]
        self._msgbuf += sig
        mav.signing.timestamp += 1

    def _pack(self, mav: "MAVLink", crc_extra: int, payload: bytes, force_mavlink1: bool = False) -> bytes:
        plen = len(payload)
        if float(WIRE_PROTOCOL_VERSION) == 2.0 and not force_mavlink1:
            # in MAVLink2 we can strip trailing zeros off payloads. This allows for simple
            # variable length arrays and smaller packets
            if sys.version_info[0] == 2:
                nullbyte = chr(0)
            else:
                nullbyte = 0
            while plen > 1 and payload[plen - 1] == nullbyte:
                plen -= 1
        self._payload = payload[:plen]
        incompat_flags = 0
        if mav.signing.sign_outgoing:
            incompat_flags |= MAVLINK_IFLAG_SIGNED
        self._header = MAVLink_header(
            self._header.msgId,
            incompat_flags=incompat_flags,
            compat_flags=0,
            mlen=len(self._payload),
            seq=mav.seq,
            srcSystem=mav.srcSystem,
            srcComponent=mav.srcComponent,
        )
        self._msgbuf = bytearray(self._header.pack(force_mavlink1=force_mavlink1))
        self._msgbuf += self._payload
        crc = x25crc(self._msgbuf[1:])
        if True:
            # we are using CRC extra
            crc.accumulate(struct.pack("B", crc_extra))
        self._crc = crc.crc
        self._msgbuf += struct.pack("<H", self._crc)
        if mav.signing.sign_outgoing and not force_mavlink1:
            self.sign_packet(mav)
        return bytes(self._msgbuf)

    def pack(self, mav: "MAVLink", force_mavlink1: bool = False) -> bytes:
        raise NotImplementedError("MAVLink_message cannot be serialized directly")

    def __getitem__(self, key: str) -> str:
        """support indexing, allowing for multi-instance sensors in one message"""
        if self._instances is None:
            raise IndexError()
        if key not in self._instances:
            raise IndexError()
        return self._instances[key]


class mavlink_msg_deprecated_name_property(object):
    """
    This handles the class variable name change from name to msgname for
    subclasses of MAVLink_message during a transition period.

    This is used by setting the class variable to
    `mavlink_msg_deprecated_name_property()`.
    """

    def __get__(self, instance: Optional[MAVLink_message], owner: Type[MAVLink_message]) -> str:
        if instance is not None:
            logger.error("Using .name on a MAVLink_message is not supported, use .get_type() instead.")
            raise AttributeError("Class {} has no attribute 'name'".format(owner.__name__))
        logger.warning(
            """Using .name on a MAVLink_message class is deprecated, consider using .msgname instead.
Note that if compatibility with pymavlink 2.4.30 and earlier is desired, use something like this:

msg_name =  msg.msgname if hasattr(msg, "msgname") else msg.name"""
        )
        return owner.msgname


# enums


class EnumEntry(object):
    def __init__(self, name: str, description: str) -> None:
        self.name = name
        self.description = description
        self.param: Dict[int, str] = {}
        self.has_location = False


enums: Dict[str, Dict[int, EnumEntry]] = {}

# message IDs
MAVLINK_MSG_ID_BAD_DATA = -1
MAVLINK_MSG_ID_UNKNOWN = -2
MAVLINK_MSG_ID_SEED_HEARTBEAT = 39205
MAVLINK_MSG_ID_LOG = 88552
MAVLINK_MSG_ID_SEED_SYSTEM_T = 79071
MAVLINK_MSG_ID_CON_CMD = 72498
MAVLINK_MSG_ID_ASSIST_NOW_UPLOAD = 21513
MAVLINK_MSG_ID_EJECTOR_SYSTEM_T = 37033
MAVLINK_MSG_ID_EJECTOR_HEARTBEAT = 66957


class MAVLink_seed_heartbeat_message(MAVLink_message):
    """
    Contains information about the current state and local time.
    """

    id = MAVLINK_MSG_ID_SEED_HEARTBEAT
    msgname = "SEED_HEARTBEAT"
    fieldnames = ["time_local", "d2time", "telecommand_cnt", "state_cur", "imu_gyro_z", "lidar_cover_open", "bat_heater_fault", "adc_measurements_sbc", "adc_measurements_cop", "available_status", "bat_status"]
    ordered_fieldnames = ["time_local", "d2time", "imu_gyro_z", "adc_measurements_sbc", "adc_measurements_cop", "telecommand_cnt", "state_cur", "lidar_cover_open", "bat_heater_fault", "available_status", "bat_status"]
    fieldtypes = ["int64_t", "uint32_t", "uint8_t", "uint8_t", "float", "uint8_t", "uint8_t", "uint16_t", "uint16_t", "uint8_t", "uint8_t"]
    fielddisplays_by_name: Dict[str, str] = {}
    fieldenums_by_name: Dict[str, str] = {}
    fieldunits_by_name: Dict[str, str] = {}
    native_format = bytearray(b"<qIfHHBBBBBB")
    orders = [0, 1, 5, 6, 2, 7, 8, 3, 4, 9, 10]
    lengths = [1, 1, 1, 8, 8, 1, 1, 1, 1, 1, 1]
    array_lengths = [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0]
    crc_extra = 120
    unpacker = struct.Struct("<qIf8H8HBBBBBB")
    instance_field = None
    instance_offset = -1

    def __init__(self, time_local: int, d2time: int, telecommand_cnt: int, state_cur: int, imu_gyro_z: float, lidar_cover_open: int, bat_heater_fault: int, adc_measurements_sbc: Sequence[int], adc_measurements_cop: Sequence[int], available_status: int, bat_status: int):
        MAVLink_message.__init__(self, MAVLink_seed_heartbeat_message.id, MAVLink_seed_heartbeat_message.msgname)
        self._fieldnames = MAVLink_seed_heartbeat_message.fieldnames
        self._instance_field = MAVLink_seed_heartbeat_message.instance_field
        self._instance_offset = MAVLink_seed_heartbeat_message.instance_offset
        self.time_local = time_local
        self.d2time = d2time
        self.telecommand_cnt = telecommand_cnt
        self.state_cur = state_cur
        self.imu_gyro_z = imu_gyro_z
        self.lidar_cover_open = lidar_cover_open
        self.bat_heater_fault = bat_heater_fault
        self.adc_measurements_sbc = adc_measurements_sbc
        self.adc_measurements_cop = adc_measurements_cop
        self.available_status = available_status
        self.bat_status = bat_status

    def pack(self, mav: "MAVLink", force_mavlink1: bool = False) -> bytes:
        return self._pack(mav, self.crc_extra, self.unpacker.pack(self.time_local, self.d2time, self.imu_gyro_z, self.adc_measurements_sbc[0], self.adc_measurements_sbc[1], self.adc_measurements_sbc[2], self.adc_measurements_sbc[3], self.adc_measurements_sbc[4], self.adc_measurements_sbc[5], self.adc_measurements_sbc[6], self.adc_measurements_sbc[7], self.adc_measurements_cop[0], self.adc_measurements_cop[1], self.adc_measurements_cop[2], self.adc_measurements_cop[3], self.adc_measurements_cop[4], self.adc_measurements_cop[5], self.adc_measurements_cop[6], self.adc_measurements_cop[7], self.telecommand_cnt, self.state_cur, self.lidar_cover_open, self.bat_heater_fault, self.available_status, self.bat_status), force_mavlink1=force_mavlink1)


# Define name on the class for backwards compatibility (it is now msgname).
# Done with setattr to hide the class variable from mypy.
setattr(MAVLink_seed_heartbeat_message, "name", mavlink_msg_deprecated_name_property())


class MAVLink_log_message(MAVLink_message):
    """
    Contains log data of the Seed
    """

    id = MAVLINK_MSG_ID_LOG
    msgname = "LOG"
    fieldnames = ["time_local", "d2time", "log_msg"]
    ordered_fieldnames = ["time_local", "d2time", "log_msg"]
    fieldtypes = ["int64_t", "uint32_t", "char"]
    fielddisplays_by_name: Dict[str, str] = {}
    fieldenums_by_name: Dict[str, str] = {}
    fieldunits_by_name: Dict[str, str] = {}
    native_format = bytearray(b"<qIc")
    orders = [0, 1, 2]
    lengths = [1, 1, 1]
    array_lengths = [0, 0, 243]
    crc_extra = 38
    unpacker = struct.Struct("<qI243s")
    instance_field = None
    instance_offset = -1

    def __init__(self, time_local: int, d2time: int, log_msg: bytes):
        MAVLink_message.__init__(self, MAVLink_log_message.id, MAVLink_log_message.msgname)
        self._fieldnames = MAVLink_log_message.fieldnames
        self._instance_field = MAVLink_log_message.instance_field
        self._instance_offset = MAVLink_log_message.instance_offset
        self.time_local = time_local
        self.d2time = d2time
        self._log_msg_raw = log_msg
        self.log_msg = log_msg.split(b"\x00", 1)[0].decode("ascii", errors="replace")

    def pack(self, mav: "MAVLink", force_mavlink1: bool = False) -> bytes:
        return self._pack(mav, self.crc_extra, self.unpacker.pack(self.time_local, self.d2time, self._log_msg_raw), force_mavlink1=force_mavlink1)


# Define name on the class for backwards compatibility (it is now msgname).
# Done with setattr to hide the class variable from mypy.
setattr(MAVLink_log_message, "name", mavlink_msg_deprecated_name_property())


class MAVLink_seed_system_t_message(MAVLink_message):
    """
    Contains the whole Seeds system_t information + local time +
    state.
    """

    id = MAVLINK_MSG_ID_SEED_SYSTEM_T
    msgname = "SEED_SYSTEM_T"
    fieldnames = ["time_local", "d2time", "mainloop_itr_cnt", "mainloop_itr_time", "telecommand_cnt", "state_cur", "iridium_RSSI", "imu_acc_x", "imu_acc_y", "imu_acc_z", "imu_gyro_x", "imu_gyro_y", "imu_gyro_z", "baro_press", "baro_temp", "adc_measurements_sbc", "adc_measurements_cop", "vacuum_baro_press", "tacho_rot_rate", "lidar_cover_open", "bat_heater_fault", "bat_status", "gps_lat", "gps_long", "gps_quality", "gps_satsUsed", "gps_hdop", "gps_alt", "filter_vel_vertical", "filter_height_ground", "filter_rotor_rot_rate", "fiter_body_rot_rate", "controller_blade_pitch", "controller_fin_angle", "controller_ids", "available_status"]
    ordered_fieldnames = ["time_local", "d2time", "mainloop_itr_cnt", "mainloop_itr_time", "imu_acc_x", "imu_acc_y", "imu_acc_z", "imu_gyro_x", "imu_gyro_y", "imu_gyro_z", "baro_press", "baro_temp", "vacuum_baro_press", "tacho_rot_rate", "gps_lat", "gps_long", "gps_hdop", "gps_alt", "filter_vel_vertical", "filter_height_ground", "filter_rotor_rot_rate", "fiter_body_rot_rate", "controller_blade_pitch", "controller_fin_angle", "adc_measurements_sbc", "adc_measurements_cop", "telecommand_cnt", "state_cur", "iridium_RSSI", "lidar_cover_open", "bat_heater_fault", "bat_status", "gps_quality", "gps_satsUsed", "controller_ids", "available_status"]
    fieldtypes = ["int64_t", "uint32_t", "uint32_t", "uint32_t", "uint8_t", "uint8_t", "uint8_t", "float", "float", "float", "float", "float", "float", "float", "float", "uint16_t", "uint16_t", "float", "float", "uint8_t", "uint8_t", "uint8_t", "float", "float", "uint8_t", "uint8_t", "float", "float", "float", "float", "float", "float", "float", "float", "uint8_t", "uint8_t"]
    fielddisplays_by_name: Dict[str, str] = {}
    fieldenums_by_name: Dict[str, str] = {}
    fieldunits_by_name: Dict[str, str] = {}
    native_format = bytearray(b"<qIIIffffffffffffffffffffHHBBBBBBBBBB")
    orders = [0, 1, 2, 3, 26, 27, 28, 4, 5, 6, 7, 8, 9, 10, 11, 24, 25, 12, 13, 29, 30, 31, 14, 15, 32, 33, 16, 17, 18, 19, 20, 21, 22, 23, 34, 35]
    lengths = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    array_lengths = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    crc_extra = 77
    unpacker = struct.Struct("<qIIIffffffffffffffffffff8H8HBBBBBBBBBB")
    instance_field = None
    instance_offset = -1

    def __init__(self, time_local: int, d2time: int, mainloop_itr_cnt: int, mainloop_itr_time: int, telecommand_cnt: int, state_cur: int, iridium_RSSI: int, imu_acc_x: float, imu_acc_y: float, imu_acc_z: float, imu_gyro_x: float, imu_gyro_y: float, imu_gyro_z: float, baro_press: float, baro_temp: float, adc_measurements_sbc: Sequence[int], adc_measurements_cop: Sequence[int], vacuum_baro_press: float, tacho_rot_rate: float, lidar_cover_open: int, bat_heater_fault: int, bat_status: int, gps_lat: float, gps_long: float, gps_quality: int, gps_satsUsed: int, gps_hdop: float, gps_alt: float, filter_vel_vertical: float, filter_height_ground: float, filter_rotor_rot_rate: float, fiter_body_rot_rate: float, controller_blade_pitch: float, controller_fin_angle: float, controller_ids: int, available_status: int):
        MAVLink_message.__init__(self, MAVLink_seed_system_t_message.id, MAVLink_seed_system_t_message.msgname)
        self._fieldnames = MAVLink_seed_system_t_message.fieldnames
        self._instance_field = MAVLink_seed_system_t_message.instance_field
        self._instance_offset = MAVLink_seed_system_t_message.instance_offset
        self.time_local = time_local
        self.d2time = d2time
        self.mainloop_itr_cnt = mainloop_itr_cnt
        self.mainloop_itr_time = mainloop_itr_time
        self.telecommand_cnt = telecommand_cnt
        self.state_cur = state_cur
        self.iridium_RSSI = iridium_RSSI
        self.imu_acc_x = imu_acc_x
        self.imu_acc_y = imu_acc_y
        self.imu_acc_z = imu_acc_z
        self.imu_gyro_x = imu_gyro_x
        self.imu_gyro_y = imu_gyro_y
        self.imu_gyro_z = imu_gyro_z
        self.baro_press = baro_press
        self.baro_temp = baro_temp
        self.adc_measurements_sbc = adc_measurements_sbc
        self.adc_measurements_cop = adc_measurements_cop
        self.vacuum_baro_press = vacuum_baro_press
        self.tacho_rot_rate = tacho_rot_rate
        self.lidar_cover_open = lidar_cover_open
        self.bat_heater_fault = bat_heater_fault
        self.bat_status = bat_status
        self.gps_lat = gps_lat
        self.gps_long = gps_long
        self.gps_quality = gps_quality
        self.gps_satsUsed = gps_satsUsed
        self.gps_hdop = gps_hdop
        self.gps_alt = gps_alt
        self.filter_vel_vertical = filter_vel_vertical
        self.filter_height_ground = filter_height_ground
        self.filter_rotor_rot_rate = filter_rotor_rot_rate
        self.fiter_body_rot_rate = fiter_body_rot_rate
        self.controller_blade_pitch = controller_blade_pitch
        self.controller_fin_angle = controller_fin_angle
        self.controller_ids = controller_ids
        self.available_status = available_status

    def pack(self, mav: "MAVLink", force_mavlink1: bool = False) -> bytes:
        return self._pack(mav, self.crc_extra, self.unpacker.pack(self.time_local, self.d2time, self.mainloop_itr_cnt, self.mainloop_itr_time, self.imu_acc_x, self.imu_acc_y, self.imu_acc_z, self.imu_gyro_x, self.imu_gyro_y, self.imu_gyro_z, self.baro_press, self.baro_temp, self.vacuum_baro_press, self.tacho_rot_rate, self.gps_lat, self.gps_long, self.gps_hdop, self.gps_alt, self.filter_vel_vertical, self.filter_height_ground, self.filter_rotor_rot_rate, self.fiter_body_rot_rate, self.controller_blade_pitch, self.controller_fin_angle, self.adc_measurements_sbc[0], self.adc_measurements_sbc[1], self.adc_measurements_sbc[2], self.adc_measurements_sbc[3], self.adc_measurements_sbc[4], self.adc_measurements_sbc[5], self.adc_measurements_sbc[6], self.adc_measurements_sbc[7], self.adc_measurements_cop[0], self.adc_measurements_cop[1], self.adc_measurements_cop[2], self.adc_measurements_cop[3], self.adc_measurements_cop[4], self.adc_measurements_cop[5], self.adc_measurements_cop[6], self.adc_measurements_cop[7], self.telecommand_cnt, self.state_cur, self.iridium_RSSI, self.lidar_cover_open, self.bat_heater_fault, self.bat_status, self.gps_quality, self.gps_satsUsed, self.controller_ids, self.available_status), force_mavlink1=force_mavlink1)


# Define name on the class for backwards compatibility (it is now msgname).
# Done with setattr to hide the class variable from mypy.
setattr(MAVLink_seed_system_t_message, "name", mavlink_msg_deprecated_name_property())


class MAVLink_con_cmd_message(MAVLink_message):
    """
    Freetext command input, one command per message.
    """

    id = MAVLINK_MSG_ID_CON_CMD
    msgname = "CON_CMD"
    fieldnames = ["con_cmd"]
    ordered_fieldnames = ["con_cmd"]
    fieldtypes = ["char"]
    fielddisplays_by_name: Dict[str, str] = {}
    fieldenums_by_name: Dict[str, str] = {}
    fieldunits_by_name: Dict[str, str] = {}
    native_format = bytearray(b"<c")
    orders = [0]
    lengths = [1]
    array_lengths = [255]
    crc_extra = 124
    unpacker = struct.Struct("<255s")
    instance_field = None
    instance_offset = -1

    def __init__(self, con_cmd: bytes):
        MAVLink_message.__init__(self, MAVLink_con_cmd_message.id, MAVLink_con_cmd_message.msgname)
        self._fieldnames = MAVLink_con_cmd_message.fieldnames
        self._instance_field = MAVLink_con_cmd_message.instance_field
        self._instance_offset = MAVLink_con_cmd_message.instance_offset
        self._con_cmd_raw = con_cmd
        self.con_cmd = con_cmd.split(b"\x00", 1)[0].decode("ascii", errors="replace")

    def pack(self, mav: "MAVLink", force_mavlink1: bool = False) -> bytes:
        return self._pack(mav, self.crc_extra, self.unpacker.pack(self._con_cmd_raw), force_mavlink1=force_mavlink1)


# Define name on the class for backwards compatibility (it is now msgname).
# Done with setattr to hide the class variable from mypy.
setattr(MAVLink_con_cmd_message, "name", mavlink_msg_deprecated_name_property())


class MAVLink_assist_now_upload_message(MAVLink_message):
    """
    contains ublox_msg
    """

    id = MAVLINK_MSG_ID_ASSIST_NOW_UPLOAD
    msgname = "ASSIST_NOW_UPLOAD"
    fieldnames = ["ublox_msg"]
    ordered_fieldnames = ["ublox_msg"]
    fieldtypes = ["uint8_t"]
    fielddisplays_by_name: Dict[str, str] = {}
    fieldenums_by_name: Dict[str, str] = {}
    fieldunits_by_name: Dict[str, str] = {}
    native_format = bytearray(b"<B")
    orders = [0]
    lengths = [255]
    array_lengths = [255]
    crc_extra = 88
    unpacker = struct.Struct("<255B")
    instance_field = None
    instance_offset = -1

    def __init__(self, ublox_msg: Sequence[int]):
        MAVLink_message.__init__(self, MAVLink_assist_now_upload_message.id, MAVLink_assist_now_upload_message.msgname)
        self._fieldnames = MAVLink_assist_now_upload_message.fieldnames
        self._instance_field = MAVLink_assist_now_upload_message.instance_field
        self._instance_offset = MAVLink_assist_now_upload_message.instance_offset
        self.ublox_msg = ublox_msg

    def pack(self, mav: "MAVLink", force_mavlink1: bool = False) -> bytes:
        return self._pack(mav, self.crc_extra, self.unpacker.pack(self.ublox_msg[0], self.ublox_msg[1], self.ublox_msg[2], self.ublox_msg[3], self.ublox_msg[4], self.ublox_msg[5], self.ublox_msg[6], self.ublox_msg[7], self.ublox_msg[8], self.ublox_msg[9], self.ublox_msg[10], self.ublox_msg[11], self.ublox_msg[12], self.ublox_msg[13], self.ublox_msg[14], self.ublox_msg[15], self.ublox_msg[16], self.ublox_msg[17], self.ublox_msg[18], self.ublox_msg[19], self.ublox_msg[20], self.ublox_msg[21], self.ublox_msg[22], self.ublox_msg[23], self.ublox_msg[24], self.ublox_msg[25], self.ublox_msg[26], self.ublox_msg[27], self.ublox_msg[28], self.ublox_msg[29], self.ublox_msg[30], self.ublox_msg[31], self.ublox_msg[32], self.ublox_msg[33], self.ublox_msg[34], self.ublox_msg[35], self.ublox_msg[36], self.ublox_msg[37], self.ublox_msg[38], self.ublox_msg[39], self.ublox_msg[40], self.ublox_msg[41], self.ublox_msg[42], self.ublox_msg[43], self.ublox_msg[44], self.ublox_msg[45], self.ublox_msg[46], self.ublox_msg[47], self.ublox_msg[48], self.ublox_msg[49], self.ublox_msg[50], self.ublox_msg[51], self.ublox_msg[52], self.ublox_msg[53], self.ublox_msg[54], self.ublox_msg[55], self.ublox_msg[56], self.ublox_msg[57], self.ublox_msg[58], self.ublox_msg[59], self.ublox_msg[60], self.ublox_msg[61], self.ublox_msg[62], self.ublox_msg[63], self.ublox_msg[64], self.ublox_msg[65], self.ublox_msg[66], self.ublox_msg[67], self.ublox_msg[68], self.ublox_msg[69], self.ublox_msg[70], self.ublox_msg[71], self.ublox_msg[72], self.ublox_msg[73], self.ublox_msg[74], self.ublox_msg[75], self.ublox_msg[76], self.ublox_msg[77], self.ublox_msg[78], self.ublox_msg[79], self.ublox_msg[80], self.ublox_msg[81], self.ublox_msg[82], self.ublox_msg[83], self.ublox_msg[84], self.ublox_msg[85], self.ublox_msg[86], self.ublox_msg[87], self.ublox_msg[88], self.ublox_msg[89], self.ublox_msg[90], self.ublox_msg[91], self.ublox_msg[92], self.ublox_msg[93], self.ublox_msg[94], self.ublox_msg[95], self.ublox_msg[96], self.ublox_msg[97], self.ublox_msg[98], self.ublox_msg[99], self.ublox_msg[100], self.ublox_msg[101], self.ublox_msg[102], self.ublox_msg[103], self.ublox_msg[104], self.ublox_msg[105], self.ublox_msg[106], self.ublox_msg[107], self.ublox_msg[108], self.ublox_msg[109], self.ublox_msg[110], self.ublox_msg[111], self.ublox_msg[112], self.ublox_msg[113], self.ublox_msg[114], self.ublox_msg[115], self.ublox_msg[116], self.ublox_msg[117], self.ublox_msg[118], self.ublox_msg[119], self.ublox_msg[120], self.ublox_msg[121], self.ublox_msg[122], self.ublox_msg[123], self.ublox_msg[124], self.ublox_msg[125], self.ublox_msg[126], self.ublox_msg[127], self.ublox_msg[128], self.ublox_msg[129], self.ublox_msg[130], self.ublox_msg[131], self.ublox_msg[132], self.ublox_msg[133], self.ublox_msg[134], self.ublox_msg[135], self.ublox_msg[136], self.ublox_msg[137], self.ublox_msg[138], self.ublox_msg[139], self.ublox_msg[140], self.ublox_msg[141], self.ublox_msg[142], self.ublox_msg[143], self.ublox_msg[144], self.ublox_msg[145], self.ublox_msg[146], self.ublox_msg[147], self.ublox_msg[148], self.ublox_msg[149], self.ublox_msg[150], self.ublox_msg[151], self.ublox_msg[152], self.ublox_msg[153], self.ublox_msg[154], self.ublox_msg[155], self.ublox_msg[156], self.ublox_msg[157], self.ublox_msg[158], self.ublox_msg[159], self.ublox_msg[160], self.ublox_msg[161], self.ublox_msg[162], self.ublox_msg[163], self.ublox_msg[164], self.ublox_msg[165], self.ublox_msg[166], self.ublox_msg[167], self.ublox_msg[168], self.ublox_msg[169], self.ublox_msg[170], self.ublox_msg[171], self.ublox_msg[172], self.ublox_msg[173], self.ublox_msg[174], self.ublox_msg[175], self.ublox_msg[176], self.ublox_msg[177], self.ublox_msg[178], self.ublox_msg[179], self.ublox_msg[180], self.ublox_msg[181], self.ublox_msg[182], self.ublox_msg[183], self.ublox_msg[184], self.ublox_msg[185], self.ublox_msg[186], self.ublox_msg[187], self.ublox_msg[188], self.ublox_msg[189], self.ublox_msg[190], self.ublox_msg[191], self.ublox_msg[192], self.ublox_msg[193], self.ublox_msg[194], self.ublox_msg[195], self.ublox_msg[196], self.ublox_msg[197], self.ublox_msg[198], self.ublox_msg[199], self.ublox_msg[200], self.ublox_msg[201], self.ublox_msg[202], self.ublox_msg[203], self.ublox_msg[204], self.ublox_msg[205], self.ublox_msg[206], self.ublox_msg[207], self.ublox_msg[208], self.ublox_msg[209], self.ublox_msg[210], self.ublox_msg[211], self.ublox_msg[212], self.ublox_msg[213], self.ublox_msg[214], self.ublox_msg[215], self.ublox_msg[216], self.ublox_msg[217], self.ublox_msg[218], self.ublox_msg[219], self.ublox_msg[220], self.ublox_msg[221], self.ublox_msg[222], self.ublox_msg[223], self.ublox_msg[224], self.ublox_msg[225], self.ublox_msg[226], self.ublox_msg[227], self.ublox_msg[228], self.ublox_msg[229], self.ublox_msg[230], self.ublox_msg[231], self.ublox_msg[232], self.ublox_msg[233], self.ublox_msg[234], self.ublox_msg[235], self.ublox_msg[236], self.ublox_msg[237], self.ublox_msg[238], self.ublox_msg[239], self.ublox_msg[240], self.ublox_msg[241], self.ublox_msg[242], self.ublox_msg[243], self.ublox_msg[244], self.ublox_msg[245], self.ublox_msg[246], self.ublox_msg[247], self.ublox_msg[248], self.ublox_msg[249], self.ublox_msg[250], self.ublox_msg[251], self.ublox_msg[252], self.ublox_msg[253], self.ublox_msg[254]), force_mavlink1=force_mavlink1)


# Define name on the class for backwards compatibility (it is now msgname).
# Done with setattr to hide the class variable from mypy.
setattr(MAVLink_assist_now_upload_message, "name", mavlink_msg_deprecated_name_property())


class MAVLink_ejector_system_t_message(MAVLink_message):
    """
    Contains the whole Ejector system_t information + local time +
    state.
    """

    id = MAVLINK_MSG_ID_EJECTOR_SYSTEM_T
    msgname = "EJECTOR_SYSTEM_T"
    fieldnames = ["time_local", "d2time", "mainloop_itr_cnt", "mainloop_itr_time", "telecommand_cnt", "state_cur"]
    ordered_fieldnames = ["time_local", "d2time", "mainloop_itr_cnt", "mainloop_itr_time", "telecommand_cnt", "state_cur"]
    fieldtypes = ["int64_t", "uint32_t", "uint32_t", "uint32_t", "uint8_t", "uint8_t"]
    fielddisplays_by_name: Dict[str, str] = {}
    fieldenums_by_name: Dict[str, str] = {}
    fieldunits_by_name: Dict[str, str] = {}
    native_format = bytearray(b"<qIIIBB")
    orders = [0, 1, 2, 3, 4, 5]
    lengths = [1, 1, 1, 1, 1, 1]
    array_lengths = [0, 0, 0, 0, 0, 0]
    crc_extra = 0
    unpacker = struct.Struct("<qIIIBB")
    instance_field = None
    instance_offset = -1

    def __init__(self, time_local: int, d2time: int, mainloop_itr_cnt: int, mainloop_itr_time: int, telecommand_cnt: int, state_cur: int):
        MAVLink_message.__init__(self, MAVLink_ejector_system_t_message.id, MAVLink_ejector_system_t_message.msgname)
        self._fieldnames = MAVLink_ejector_system_t_message.fieldnames
        self._instance_field = MAVLink_ejector_system_t_message.instance_field
        self._instance_offset = MAVLink_ejector_system_t_message.instance_offset
        self.time_local = time_local
        self.d2time = d2time
        self.mainloop_itr_cnt = mainloop_itr_cnt
        self.mainloop_itr_time = mainloop_itr_time
        self.telecommand_cnt = telecommand_cnt
        self.state_cur = state_cur

    def pack(self, mav: "MAVLink", force_mavlink1: bool = False) -> bytes:
        return self._pack(mav, self.crc_extra, self.unpacker.pack(self.time_local, self.d2time, self.mainloop_itr_cnt, self.mainloop_itr_time, self.telecommand_cnt, self.state_cur), force_mavlink1=force_mavlink1)


# Define name on the class for backwards compatibility (it is now msgname).
# Done with setattr to hide the class variable from mypy.
setattr(MAVLink_ejector_system_t_message, "name", mavlink_msg_deprecated_name_property())


class MAVLink_ejector_heartbeat_message(MAVLink_message):
    """
    Contains information about the current state and local time.
    """

    id = MAVLINK_MSG_ID_EJECTOR_HEARTBEAT
    msgname = "EJECTOR_HEARTBEAT"
    fieldnames = ["time_local", "d2time", "telecommand_cnt", "state_cur", "led_enabled", "cam_enabled", "seed_power_enabled", "seed_a_present", "seed_b_present"]
    ordered_fieldnames = ["time_local", "d2time", "telecommand_cnt", "state_cur", "led_enabled", "cam_enabled", "seed_power_enabled", "seed_a_present", "seed_b_present"]
    fieldtypes = ["int64_t", "uint32_t", "uint8_t", "uint8_t", "uint8_t", "uint8_t", "uint8_t", "uint8_t", "uint8_t"]
    fielddisplays_by_name: Dict[str, str] = {}
    fieldenums_by_name: Dict[str, str] = {}
    fieldunits_by_name: Dict[str, str] = {}
    native_format = bytearray(b"<qIBBBBBBB")
    orders = [0, 1, 2, 3, 4, 5, 6, 7, 8]
    lengths = [1, 1, 1, 1, 1, 1, 1, 1, 1]
    array_lengths = [0, 0, 0, 0, 0, 0, 0, 0, 0]
    crc_extra = 87
    unpacker = struct.Struct("<qIBBBBBBB")
    instance_field = None
    instance_offset = -1

    def __init__(self, time_local: int, d2time: int, telecommand_cnt: int, state_cur: int, led_enabled: int, cam_enabled: int, seed_power_enabled: int, seed_a_present: int, seed_b_present: int):
        MAVLink_message.__init__(self, MAVLink_ejector_heartbeat_message.id, MAVLink_ejector_heartbeat_message.msgname)
        self._fieldnames = MAVLink_ejector_heartbeat_message.fieldnames
        self._instance_field = MAVLink_ejector_heartbeat_message.instance_field
        self._instance_offset = MAVLink_ejector_heartbeat_message.instance_offset
        self.time_local = time_local
        self.d2time = d2time
        self.telecommand_cnt = telecommand_cnt
        self.state_cur = state_cur
        self.led_enabled = led_enabled
        self.cam_enabled = cam_enabled
        self.seed_power_enabled = seed_power_enabled
        self.seed_a_present = seed_a_present
        self.seed_b_present = seed_b_present

    def pack(self, mav: "MAVLink", force_mavlink1: bool = False) -> bytes:
        return self._pack(mav, self.crc_extra, self.unpacker.pack(self.time_local, self.d2time, self.telecommand_cnt, self.state_cur, self.led_enabled, self.cam_enabled, self.seed_power_enabled, self.seed_a_present, self.seed_b_present), force_mavlink1=force_mavlink1)


# Define name on the class for backwards compatibility (it is now msgname).
# Done with setattr to hide the class variable from mypy.
setattr(MAVLink_ejector_heartbeat_message, "name", mavlink_msg_deprecated_name_property())


mavlink_map: Dict[int, Type[MAVLink_message]] = {
    MAVLINK_MSG_ID_SEED_HEARTBEAT: MAVLink_seed_heartbeat_message,
    MAVLINK_MSG_ID_LOG: MAVLink_log_message,
    MAVLINK_MSG_ID_SEED_SYSTEM_T: MAVLink_seed_system_t_message,
    MAVLINK_MSG_ID_CON_CMD: MAVLink_con_cmd_message,
    MAVLINK_MSG_ID_ASSIST_NOW_UPLOAD: MAVLink_assist_now_upload_message,
    MAVLINK_MSG_ID_EJECTOR_SYSTEM_T: MAVLink_ejector_system_t_message,
    MAVLINK_MSG_ID_EJECTOR_HEARTBEAT: MAVLink_ejector_heartbeat_message,
}


class MAVError(Exception):
    """MAVLink error class"""

    def __init__(self, msg: str) -> None:
        Exception.__init__(self, msg)
        self.message = msg


class MAVLink_bad_data(MAVLink_message):
    """
    a piece of bad data in a mavlink stream
    """

    def __init__(self, data: bytes, reason: str) -> None:
        MAVLink_message.__init__(self, MAVLINK_MSG_ID_BAD_DATA, "BAD_DATA")
        self._fieldnames = ["data", "reason"]
        self.data = data
        self.reason = reason
        self._msgbuf = bytearray(data)
        self._instance_field = None

    def __str__(self) -> str:
        """Override the __str__ function from MAVLink_messages because non-printable characters are common in to be the reason for this message to exist."""
        if sys.version_info[0] == 2:
            hexstr = ["{:x}".format(ord(i)) for i in self.data]
        else:
            hexstr = ["{:x}".format(i) for i in self.data]
        return "%s {%s, data:%s}" % (self._type, self.reason, hexstr)


class MAVLink_unknown(MAVLink_message):
    """
    a message that we don't have in the XML used when built
    """

    def __init__(self, msgid: int, data: bytes) -> None:
        MAVLink_message.__init__(self, MAVLINK_MSG_ID_UNKNOWN, "UNKNOWN_%u" % msgid)
        self._fieldnames = ["data"]
        self.data = data
        self._msgbuf = bytearray(data)
        self._instance_field = None

    def __str__(self) -> str:
        """Override the __str__ function from MAVLink_messages because non-printable characters are common."""
        if sys.version_info[0] == 2:
            hexstr = ["{:x}".format(ord(i)) for i in self.data]
        else:
            hexstr = ["{:x}".format(i) for i in self.data]
        return "%s {data:%s}" % (self._type, hexstr)


class MAVLinkSigning(object):
    """MAVLink signing state class"""

    def __init__(self) -> None:
        self.secret_key: Optional[bytes] = None
        self.timestamp = 0
        self.link_id = 0
        self.sign_outgoing = False
        self.allow_unsigned_callback: Optional[Callable[["MAVLink", int], bool]] = None
        self.stream_timestamps: Dict[Tuple[int, int, int], int] = {}
        self.sig_count = 0
        self.badsig_count = 0
        self.goodsig_count = 0
        self.unsigned_count = 0
        self.reject_count = 0


class MAVLink(object):
    """MAVLink protocol handling class"""

    def __init__(self, file: Any, srcSystem: int = 0, srcComponent: int = 0, use_native: bool = False) -> None:
        self.seq = 0
        self.file = file
        self.srcSystem = srcSystem
        self.srcComponent = srcComponent
        self.callback: Optional[Callable[..., None]] = None
        self.callback_args: Optional[Iterable[Any]] = None
        self.callback_kwargs: Optional[Mapping[str, Any]] = None
        self.send_callback: Optional[Callable[..., None]] = None
        self.send_callback_args: Optional[Iterable[Any]] = None
        self.send_callback_kwargs: Optional[Mapping[str, Any]] = None
        self.buf = bytearray()
        self.buf_index = 0
        self.expected_length = HEADER_LEN_V1 + 2
        self.have_prefix_error = False
        self.robust_parsing = False
        self.protocol_marker = 253
        self.little_endian = True
        self.crc_extra = True
        self.sort_fields = True
        self.total_packets_sent = 0
        self.total_bytes_sent = 0
        self.total_packets_received = 0
        self.total_bytes_received = 0
        self.total_receive_errors = 0
        self.startup_time = time.time()
        self.signing = MAVLinkSigning()
        self.mav20_unpacker = struct.Struct("<cBBBBBBHB")
        self.mav10_unpacker = struct.Struct("<cBBBBB")
        self.mav20_h3_unpacker = struct.Struct("BBB")
        self.mav_csum_unpacker = struct.Struct("<H")
        self.mav_sign_unpacker = struct.Struct("<IH")

    def set_callback(self, callback: Callable[..., None], *args: Any, **kwargs: Any) -> None:
        self.callback = callback
        self.callback_args = args
        self.callback_kwargs = kwargs

    def set_send_callback(self, callback: Callable[..., None], *args: Any, **kwargs: Any) -> None:
        self.send_callback = callback
        self.send_callback_args = args
        self.send_callback_kwargs = kwargs

    def send(self, mavmsg: MAVLink_message, force_mavlink1: bool = False) -> None:
        """send a MAVLink message"""
        buf = mavmsg.pack(self, force_mavlink1=force_mavlink1)
        self.file.write(buf)
        self.seq = (self.seq + 1) % 256
        self.total_packets_sent += 1
        self.total_bytes_sent += len(buf)
        if self.send_callback is not None and self.send_callback_args is not None and self.send_callback_kwargs is not None:
            self.send_callback(mavmsg, *self.send_callback_args, **self.send_callback_kwargs)

    def buf_len(self) -> int:
        return len(self.buf) - self.buf_index

    def bytes_needed(self) -> int:
        """return number of bytes needed for next parsing stage"""
        ret = self.expected_length - self.buf_len()

        if ret <= 0:
            return 1
        return ret

    def __callbacks(self, msg: MAVLink_message) -> None:
        """this method exists only to make profiling results easier to read"""
        if self.callback is not None and self.callback_args is not None and self.callback_kwargs is not None:
            self.callback(msg, *self.callback_args, **self.callback_kwargs)

    def parse_char(self, c: Sequence[int]) -> Optional[MAVLink_message]:
        """input some data bytes, possibly returning a new message"""
        self.buf.extend(c)

        self.total_bytes_received += len(c)

        m = self.__parse_char_legacy()

        if m is not None:
            self.total_packets_received += 1
            self.__callbacks(m)
        else:
            # XXX The idea here is if we've read something and there's nothing left in
            # the buffer, reset it to 0 which frees the memory
            if self.buf_len() == 0 and self.buf_index != 0:
                self.buf = bytearray()
                self.buf_index = 0

        return m

    def __parse_char_legacy(self) -> Optional[MAVLink_message]:
        """input some data bytes, possibly returning a new message"""
        header_len = HEADER_LEN_V1
        if self.buf_len() >= 1 and self.buf[self.buf_index] == PROTOCOL_MARKER_V2:
            header_len = HEADER_LEN_V2

        m: Optional[MAVLink_message] = None
        if self.buf_len() >= 1 and self.buf[self.buf_index] != PROTOCOL_MARKER_V1 and self.buf[self.buf_index] != PROTOCOL_MARKER_V2:
            magic = self.buf[self.buf_index]
            self.buf_index += 1
            if self.robust_parsing:
                m = MAVLink_bad_data(bytearray([magic]), "Bad prefix")
                self.expected_length = header_len + 2
                self.total_receive_errors += 1
                return m
            if self.have_prefix_error:
                return None
            self.have_prefix_error = True
            self.total_receive_errors += 1
            raise MAVError("invalid MAVLink prefix '%s'" % magic)
        self.have_prefix_error = False
        if self.buf_len() >= 3:
            sbuf = self.buf[self.buf_index : 3 + self.buf_index]
            (magic, self.expected_length, incompat_flags) = cast(
                Tuple[int, int, int],
                self.mav20_h3_unpacker.unpack(sbuf),
            )
            if magic == PROTOCOL_MARKER_V2 and (incompat_flags & MAVLINK_IFLAG_SIGNED):
                self.expected_length += MAVLINK_SIGNATURE_BLOCK_LEN
            self.expected_length += header_len + 2
        if self.expected_length >= (header_len + 2) and self.buf_len() >= self.expected_length:
            mbuf = self.buf[self.buf_index : self.buf_index + self.expected_length]
            self.buf_index += self.expected_length
            self.expected_length = header_len + 2
            if self.robust_parsing:
                try:
                    if magic == PROTOCOL_MARKER_V2 and (incompat_flags & ~MAVLINK_IFLAG_SIGNED) != 0:
                        raise MAVError("invalid incompat_flags 0x%x 0x%x %u" % (incompat_flags, magic, self.expected_length))
                    m = self.decode(mbuf)
                except MAVError as reason:
                    m = MAVLink_bad_data(mbuf, reason.message)
                    self.total_receive_errors += 1
            else:
                if magic == PROTOCOL_MARKER_V2 and (incompat_flags & ~MAVLINK_IFLAG_SIGNED) != 0:
                    raise MAVError("invalid incompat_flags 0x%x 0x%x %u" % (incompat_flags, magic, self.expected_length))
                m = self.decode(mbuf)
            return m
        return None

    def parse_buffer(self, s: Sequence[int]) -> Optional[List[MAVLink_message]]:
        """input some data bytes, possibly returning a list of new messages"""
        m = self.parse_char(s)
        if m is None:
            return None
        ret = [m]
        while True:
            m = self.parse_char(b"")
            if m is None:
                return ret
            ret.append(m)

    def check_signature(self, msgbuf: bytearray, srcSystem: int, srcComponent: int) -> bool:
        """check signature on incoming message"""
        assert self.signing.secret_key is not None

        timestamp_buf = msgbuf[-12:-6]
        link_id = msgbuf[-13]
        (tlow, thigh) = cast(
            Tuple[int, int],
            self.mav_sign_unpacker.unpack(timestamp_buf),
        )
        timestamp = tlow + (thigh << 32)

        # see if the timestamp is acceptable
        stream_key = (link_id, srcSystem, srcComponent)
        if stream_key in self.signing.stream_timestamps:
            if timestamp <= self.signing.stream_timestamps[stream_key]:
                # reject old timestamp
                logger.info("old timestamp")
                return False
        else:
            # a new stream has appeared. Accept the timestamp if it is at most
            # one minute behind our current timestamp
            if timestamp + 6000 * 1000 < self.signing.timestamp:
                logger.info("bad new stream %s %s", timestamp / (100.0 * 1000 * 60 * 60 * 24 * 365), self.signing.timestamp / (100.0 * 1000 * 60 * 60 * 24 * 365))
                return False
            self.signing.stream_timestamps[stream_key] = timestamp
            logger.info("new stream")

        h = hashlib.new("sha256")
        h.update(self.signing.secret_key)
        h.update(msgbuf[:-6])
        sig1 = h.digest()[:6]
        sig2 = msgbuf[-6:]
        if sig1 != sig2:
            logger.info("sig mismatch")
            return False

        # the timestamp we next send with is the max of the received timestamp and
        # our current timestamp
        self.signing.timestamp = max(self.signing.timestamp, timestamp)
        return True

    def decode(self, msgbuf: bytearray) -> MAVLink_message:
        """decode a buffer as a MAVLink message"""
        # decode the header
        if msgbuf[0] != PROTOCOL_MARKER_V1:
            headerlen = 10
            try:
                magic, mlen, incompat_flags, compat_flags, seq, srcSystem, srcComponent, msgIdlow, msgIdhigh = cast(
                    Tuple[bytes, int, int, int, int, int, int, int, int],
                    self.mav20_unpacker.unpack(msgbuf[:headerlen]),
                )
            except struct.error as emsg:
                raise MAVError("Unable to unpack MAVLink header: %s" % emsg)
            msgId = msgIdlow | (msgIdhigh << 16)
            mapkey = msgId
        else:
            headerlen = 6
            try:
                magic, mlen, seq, srcSystem, srcComponent, msgId = cast(
                    Tuple[bytes, int, int, int, int, int],
                    self.mav10_unpacker.unpack(msgbuf[:headerlen]),
                )
                incompat_flags = 0
                compat_flags = 0
            except struct.error as emsg:
                raise MAVError("Unable to unpack MAVLink header: %s" % emsg)
            mapkey = msgId
        if (incompat_flags & MAVLINK_IFLAG_SIGNED) != 0:
            signature_len = MAVLINK_SIGNATURE_BLOCK_LEN
        else:
            signature_len = 0

        if ord(magic) != PROTOCOL_MARKER_V1 and ord(magic) != PROTOCOL_MARKER_V2:
            raise MAVError("invalid MAVLink prefix '{}'".format(hex(ord(magic))))
        if mlen != len(msgbuf) - (headerlen + 2 + signature_len):
            raise MAVError("invalid MAVLink message length. Got %u expected %u, msgId=%u headerlen=%u" % (len(msgbuf) - (headerlen + 2 + signature_len), mlen, msgId, headerlen))

        if mapkey not in mavlink_map:
            return MAVLink_unknown(msgId, msgbuf)

        # decode the payload
        msgtype = mavlink_map[mapkey]
        order_map = msgtype.orders
        len_map = msgtype.lengths
        crc_extra = msgtype.crc_extra

        # decode the checksum
        try:
            (crc,) = cast(
                Tuple[int],
                self.mav_csum_unpacker.unpack(msgbuf[-(2 + signature_len) :][:2]),
            )
        except struct.error as emsg:
            raise MAVError("Unable to unpack MAVLink CRC: %s" % emsg)
        crcbuf = msgbuf[1 : -(2 + signature_len)]
        if True:
            # using CRC extra
            crcbuf.append(crc_extra)
        crc2 = x25crc(crcbuf)
        if crc != crc2.crc and not MAVLINK_IGNORE_CRC:
            raise MAVError("invalid MAVLink CRC in msgID %u 0x%04x should be 0x%04x" % (msgId, crc, crc2.crc))

        sig_ok = False
        if signature_len == MAVLINK_SIGNATURE_BLOCK_LEN:
            self.signing.sig_count += 1
        if self.signing.secret_key is not None:
            accept_signature = False
            if signature_len == MAVLINK_SIGNATURE_BLOCK_LEN:
                sig_ok = self.check_signature(msgbuf, srcSystem, srcComponent)
                accept_signature = sig_ok
                if sig_ok:
                    self.signing.goodsig_count += 1
                else:
                    self.signing.badsig_count += 1
                if not accept_signature and self.signing.allow_unsigned_callback is not None:
                    accept_signature = self.signing.allow_unsigned_callback(self, msgId)
                    if accept_signature:
                        self.signing.unsigned_count += 1
                    else:
                        self.signing.reject_count += 1
            elif self.signing.allow_unsigned_callback is not None:
                accept_signature = self.signing.allow_unsigned_callback(self, msgId)
                if accept_signature:
                    self.signing.unsigned_count += 1
                else:
                    self.signing.reject_count += 1
            if not accept_signature:
                raise MAVError("Invalid signature")

        csize = msgtype.unpacker.size
        mbuf = msgbuf[headerlen : -(2 + signature_len)]
        if len(mbuf) < csize:
            # zero pad to give right size
            mbuf.extend([0] * (csize - len(mbuf)))
        if len(mbuf) < csize:
            raise MAVError("Bad message of type %s length %u needs %s" % (msgtype, len(mbuf), csize))
        mbuf = mbuf[:csize]
        try:
            t = cast(
                Tuple[Union[bytes, int, float], ...],
                msgtype.unpacker.unpack(mbuf),
            )
        except struct.error as emsg:
            raise MAVError("Unable to unpack MAVLink payload type=%s payloadLength=%u: %s" % (msgtype, len(mbuf), emsg))

        tlist: List[Union[bytes, float, int, Sequence[float], Sequence[int]]] = list(t)
        # handle sorted fields
        if True:
            if sum(len_map) == len(len_map):
                # message has no arrays in it
                for i in range(0, len(tlist)):
                    tlist[i] = t[order_map[i]]
            else:
                # message has some arrays
                tlist = []
                for i in range(0, len(order_map)):
                    order = order_map[i]
                    L = len_map[order]
                    tip = sum(len_map[:order])
                    field = t[tip]
                    if L == 1 or isinstance(field, bytes):
                        tlist.append(field)
                    else:
                        tlist.append(cast(Union[Sequence[int], Sequence[float]], list(t[tip : (tip + L)])))

        # terminate any strings
        for i, elem in enumerate(tlist):
            if isinstance(elem, bytes):
                tlist[i] = elem.rstrip(b"\x00")

        # construct the message object
        try:
            # Note that initializers don't follow the Liskov Substitution Principle
            # therefore it can't be typechecked
            m = msgtype(*tlist)  # type: ignore
        except Exception as emsg:
            raise MAVError("Unable to instantiate MAVLink message of type %s : %s" % (msgtype, emsg))
        m._signed = sig_ok
        if m._signed:
            m._link_id = msgbuf[-13]
        m._msgbuf = msgbuf
        m._payload = msgbuf[6 : -(2 + signature_len)]
        m._crc = crc
        m._header = MAVLink_header(msgId, incompat_flags, compat_flags, mlen, seq, srcSystem, srcComponent)
        return m

    def seed_heartbeat_encode(self, time_local: int, d2time: int, telecommand_cnt: int, state_cur: int, imu_gyro_z: float, lidar_cover_open: int, bat_heater_fault: int, adc_measurements_sbc: Sequence[int], adc_measurements_cop: Sequence[int], available_status: int, bat_status: int) -> MAVLink_seed_heartbeat_message:
        """
        Contains information about the current state and local time.

        time_local                : Seed local time (type:int64_t)
        d2time                    : system time (type:uint32_t)
        telecommand_cnt           : number of received and executed telecommands (type:uint8_t)
        state_cur                 : current System state (type:uint8_t)
        imu_gyro_z                : angular velocity around z-axis (type:float)
        lidar_cover_open          : Is the LIDAR Hole currently open? (type:uint8_t)
        bat_heater_fault          : truthy if heater fault occurred (type:uint8_t)
        adc_measurements_sbc        : adc measurements millivolts/milliamps (type:uint16_t)
        adc_measurements_cop        : adc measurements millivolts/milliamps (type:uint16_t)
        available_status          : imu_gyro_avail, copAdcAvail, sbcAdcAvail in this order with individual size of 1 bit (type:uint8_t)
        bat_status                : rxsm_allowed, bat1_allowed and bat2_allowed, rxsm_used, bat1_used, bat2_used and bat_heating_enabled in this order with individual size of 1 bit. (type:uint8_t)

        """
        return MAVLink_seed_heartbeat_message(time_local, d2time, telecommand_cnt, state_cur, imu_gyro_z, lidar_cover_open, bat_heater_fault, adc_measurements_sbc, adc_measurements_cop, available_status, bat_status)

    def seed_heartbeat_send(self, time_local: int, d2time: int, telecommand_cnt: int, state_cur: int, imu_gyro_z: float, lidar_cover_open: int, bat_heater_fault: int, adc_measurements_sbc: Sequence[int], adc_measurements_cop: Sequence[int], available_status: int, bat_status: int, force_mavlink1: bool = False) -> None:
        """
        Contains information about the current state and local time.

        time_local                : Seed local time (type:int64_t)
        d2time                    : system time (type:uint32_t)
        telecommand_cnt           : number of received and executed telecommands (type:uint8_t)
        state_cur                 : current System state (type:uint8_t)
        imu_gyro_z                : angular velocity around z-axis (type:float)
        lidar_cover_open          : Is the LIDAR Hole currently open? (type:uint8_t)
        bat_heater_fault          : truthy if heater fault occurred (type:uint8_t)
        adc_measurements_sbc        : adc measurements millivolts/milliamps (type:uint16_t)
        adc_measurements_cop        : adc measurements millivolts/milliamps (type:uint16_t)
        available_status          : imu_gyro_avail, copAdcAvail, sbcAdcAvail in this order with individual size of 1 bit (type:uint8_t)
        bat_status                : rxsm_allowed, bat1_allowed and bat2_allowed, rxsm_used, bat1_used, bat2_used and bat_heating_enabled in this order with individual size of 1 bit. (type:uint8_t)

        """
        self.send(self.seed_heartbeat_encode(time_local, d2time, telecommand_cnt, state_cur, imu_gyro_z, lidar_cover_open, bat_heater_fault, adc_measurements_sbc, adc_measurements_cop, available_status, bat_status), force_mavlink1=force_mavlink1)

    def log_encode(self, time_local: int, d2time: int, log_msg: bytes) -> MAVLink_log_message:
        """
        Contains log data of the Seed

        time_local                : Seed local time (type:int64_t)
        d2time                    : system time (type:uint32_t)
        log_msg                   : Logging data (type:char)

        """
        return MAVLink_log_message(time_local, d2time, log_msg)

    def log_send(self, time_local: int, d2time: int, log_msg: bytes, force_mavlink1: bool = False) -> None:
        """
        Contains log data of the Seed

        time_local                : Seed local time (type:int64_t)
        d2time                    : system time (type:uint32_t)
        log_msg                   : Logging data (type:char)

        """
        self.send(self.log_encode(time_local, d2time, log_msg), force_mavlink1=force_mavlink1)

    def seed_system_t_encode(self, time_local: int, d2time: int, mainloop_itr_cnt: int, mainloop_itr_time: int, telecommand_cnt: int, state_cur: int, iridium_RSSI: int, imu_acc_x: float, imu_acc_y: float, imu_acc_z: float, imu_gyro_x: float, imu_gyro_y: float, imu_gyro_z: float, baro_press: float, baro_temp: float, adc_measurements_sbc: Sequence[int], adc_measurements_cop: Sequence[int], vacuum_baro_press: float, tacho_rot_rate: float, lidar_cover_open: int, bat_heater_fault: int, bat_status: int, gps_lat: float, gps_long: float, gps_quality: int, gps_satsUsed: int, gps_hdop: float, gps_alt: float, filter_vel_vertical: float, filter_height_ground: float, filter_rotor_rot_rate: float, fiter_body_rot_rate: float, controller_blade_pitch: float, controller_fin_angle: float, controller_ids: int, available_status: int) -> MAVLink_seed_system_t_message:
        """
        Contains the whole Seeds system_t information + local time + state.

        time_local                : Seed local time (type:int64_t)
        d2time                    : system time (type:uint32_t)
        mainloop_itr_cnt          : number of the current iteration of the mainloop (type:uint32_t)
        mainloop_itr_time         : time the last mainloop iteration took (type:uint32_t)
        telecommand_cnt           : number of received and executed telecommands (type:uint8_t)
        state_cur                 : current System state (type:uint8_t)
        iridium_RSSI              : Indicates the signal quality of Iridium (type:uint8_t)
        imu_acc_x                 : acceleration along x-axis, multiple of g (type:float)
        imu_acc_y                 : acceleration along y-axis, multiple of g (type:float)
        imu_acc_z                 : acceleration along z-axis, multiple of g (type:float)
        imu_gyro_x                : angular velocity around x-axis (type:float)
        imu_gyro_y                : angular velocity around y-axis (type:float)
        imu_gyro_z                : angular velocity around z-axis (type:float)
        baro_press                : air pressure (type:float)
        baro_temp                 : temperature in degrees Celsius (type:float)
        adc_measurements_sbc        : adc measurements millivolts/milliamps (type:uint16_t)
        adc_measurements_cop        : adc measurements millivolts/milliamps (type:uint16_t)
        vacuum_baro_press         : air pressure (type:float)
        tacho_rot_rate            : rotation rate of the rotor in rad/s (type:float)
        lidar_cover_open          : Is the LIDAR Hole currently open? (type:uint8_t)
        bat_heater_fault          : truthy if heater fault occurred (type:uint8_t)
        bat_status                : rxsm_allowed, bat1_allowed and bat2_allowed, rxsm_used, bat1_used, bat2_used and bat_heating_enabled in this order with individual size of 1 bit. (type:uint8_t)
        gps_lat                   : current latitude (N is positiv, S is negativ) (type:float)
        gps_long                  : current longitude (W is positiv, E is negativ) (type:float)
        gps_quality               : indicator for gps fix (type:uint8_t)
        gps_satsUsed              : number of used satellites (type:uint8_t)
        gps_hdop                  : horizontal dilution of precision (type:float)
        gps_alt                   : altitude above mean sea level (type:float)
        filter_vel_vertical        : vertical velocity of the seed in m/s  negative if seed is falling (type:float)
        filter_height_ground        : height above ground in m (type:float)
        filter_rotor_rot_rate        : absolute (to air/world frame) rotation rate of the rotor in rad/s" (type:float)
        fiter_body_rot_rate        : absolute (to air/world frame) rotation rate of the body in rad/s" (type:float)
        controller_blade_pitch        : setpoint for the pitch angle for the servos (type:float)
        controller_fin_angle        : desired fin angle (type:float)
        controller_ids            : identifier for blade controller type and finn controller type in this order with individual size of 4 bit. (type:uint8_t)
        available_status          : imu_acc_avail, imu_gyro_avail, baro_avail, vacuum_baro_avail, tacho_rot_avail, copAdcAvail, sbcAdcAvail in this order with individual size of 1 bit (type:uint8_t)

        """
        return MAVLink_seed_system_t_message(time_local, d2time, mainloop_itr_cnt, mainloop_itr_time, telecommand_cnt, state_cur, iridium_RSSI, imu_acc_x, imu_acc_y, imu_acc_z, imu_gyro_x, imu_gyro_y, imu_gyro_z, baro_press, baro_temp, adc_measurements_sbc, adc_measurements_cop, vacuum_baro_press, tacho_rot_rate, lidar_cover_open, bat_heater_fault, bat_status, gps_lat, gps_long, gps_quality, gps_satsUsed, gps_hdop, gps_alt, filter_vel_vertical, filter_height_ground, filter_rotor_rot_rate, fiter_body_rot_rate, controller_blade_pitch, controller_fin_angle, controller_ids, available_status)

    def seed_system_t_send(self, time_local: int, d2time: int, mainloop_itr_cnt: int, mainloop_itr_time: int, telecommand_cnt: int, state_cur: int, iridium_RSSI: int, imu_acc_x: float, imu_acc_y: float, imu_acc_z: float, imu_gyro_x: float, imu_gyro_y: float, imu_gyro_z: float, baro_press: float, baro_temp: float, adc_measurements_sbc: Sequence[int], adc_measurements_cop: Sequence[int], vacuum_baro_press: float, tacho_rot_rate: float, lidar_cover_open: int, bat_heater_fault: int, bat_status: int, gps_lat: float, gps_long: float, gps_quality: int, gps_satsUsed: int, gps_hdop: float, gps_alt: float, filter_vel_vertical: float, filter_height_ground: float, filter_rotor_rot_rate: float, fiter_body_rot_rate: float, controller_blade_pitch: float, controller_fin_angle: float, controller_ids: int, available_status: int, force_mavlink1: bool = False) -> None:
        """
        Contains the whole Seeds system_t information + local time + state.

        time_local                : Seed local time (type:int64_t)
        d2time                    : system time (type:uint32_t)
        mainloop_itr_cnt          : number of the current iteration of the mainloop (type:uint32_t)
        mainloop_itr_time         : time the last mainloop iteration took (type:uint32_t)
        telecommand_cnt           : number of received and executed telecommands (type:uint8_t)
        state_cur                 : current System state (type:uint8_t)
        iridium_RSSI              : Indicates the signal quality of Iridium (type:uint8_t)
        imu_acc_x                 : acceleration along x-axis, multiple of g (type:float)
        imu_acc_y                 : acceleration along y-axis, multiple of g (type:float)
        imu_acc_z                 : acceleration along z-axis, multiple of g (type:float)
        imu_gyro_x                : angular velocity around x-axis (type:float)
        imu_gyro_y                : angular velocity around y-axis (type:float)
        imu_gyro_z                : angular velocity around z-axis (type:float)
        baro_press                : air pressure (type:float)
        baro_temp                 : temperature in degrees Celsius (type:float)
        adc_measurements_sbc        : adc measurements millivolts/milliamps (type:uint16_t)
        adc_measurements_cop        : adc measurements millivolts/milliamps (type:uint16_t)
        vacuum_baro_press         : air pressure (type:float)
        tacho_rot_rate            : rotation rate of the rotor in rad/s (type:float)
        lidar_cover_open          : Is the LIDAR Hole currently open? (type:uint8_t)
        bat_heater_fault          : truthy if heater fault occurred (type:uint8_t)
        bat_status                : rxsm_allowed, bat1_allowed and bat2_allowed, rxsm_used, bat1_used, bat2_used and bat_heating_enabled in this order with individual size of 1 bit. (type:uint8_t)
        gps_lat                   : current latitude (N is positiv, S is negativ) (type:float)
        gps_long                  : current longitude (W is positiv, E is negativ) (type:float)
        gps_quality               : indicator for gps fix (type:uint8_t)
        gps_satsUsed              : number of used satellites (type:uint8_t)
        gps_hdop                  : horizontal dilution of precision (type:float)
        gps_alt                   : altitude above mean sea level (type:float)
        filter_vel_vertical        : vertical velocity of the seed in m/s  negative if seed is falling (type:float)
        filter_height_ground        : height above ground in m (type:float)
        filter_rotor_rot_rate        : absolute (to air/world frame) rotation rate of the rotor in rad/s" (type:float)
        fiter_body_rot_rate        : absolute (to air/world frame) rotation rate of the body in rad/s" (type:float)
        controller_blade_pitch        : setpoint for the pitch angle for the servos (type:float)
        controller_fin_angle        : desired fin angle (type:float)
        controller_ids            : identifier for blade controller type and finn controller type in this order with individual size of 4 bit. (type:uint8_t)
        available_status          : imu_acc_avail, imu_gyro_avail, baro_avail, vacuum_baro_avail, tacho_rot_avail, copAdcAvail, sbcAdcAvail in this order with individual size of 1 bit (type:uint8_t)

        """
        self.send(self.seed_system_t_encode(time_local, d2time, mainloop_itr_cnt, mainloop_itr_time, telecommand_cnt, state_cur, iridium_RSSI, imu_acc_x, imu_acc_y, imu_acc_z, imu_gyro_x, imu_gyro_y, imu_gyro_z, baro_press, baro_temp, adc_measurements_sbc, adc_measurements_cop, vacuum_baro_press, tacho_rot_rate, lidar_cover_open, bat_heater_fault, bat_status, gps_lat, gps_long, gps_quality, gps_satsUsed, gps_hdop, gps_alt, filter_vel_vertical, filter_height_ground, filter_rotor_rot_rate, fiter_body_rot_rate, controller_blade_pitch, controller_fin_angle, controller_ids, available_status), force_mavlink1=force_mavlink1)

    def con_cmd_encode(self, con_cmd: bytes) -> MAVLink_con_cmd_message:
        """
        Freetext command input, one command per message.

        con_cmd                   : CMD content (type:char)

        """
        return MAVLink_con_cmd_message(con_cmd)

    def con_cmd_send(self, con_cmd: bytes, force_mavlink1: bool = False) -> None:
        """
        Freetext command input, one command per message.

        con_cmd                   : CMD content (type:char)

        """
        self.send(self.con_cmd_encode(con_cmd), force_mavlink1=force_mavlink1)

    def assist_now_upload_encode(self, ublox_msg: Sequence[int]) -> MAVLink_assist_now_upload_message:
        """
        contains ublox_msg

        ublox_msg                 : ublox_msg (type:uint8_t)

        """
        return MAVLink_assist_now_upload_message(ublox_msg)

    def assist_now_upload_send(self, ublox_msg: Sequence[int], force_mavlink1: bool = False) -> None:
        """
        contains ublox_msg

        ublox_msg                 : ublox_msg (type:uint8_t)

        """
        self.send(self.assist_now_upload_encode(ublox_msg), force_mavlink1=force_mavlink1)

    def ejector_system_t_encode(self, time_local: int, d2time: int, mainloop_itr_cnt: int, mainloop_itr_time: int, telecommand_cnt: int, state_cur: int) -> MAVLink_ejector_system_t_message:
        """
        Contains the whole Ejector system_t information + local time + state.

        time_local                : Ejector local time (type:int64_t)
        d2time                    : system time (type:uint32_t)
        mainloop_itr_cnt          : number of the current iteration of the mainloop (type:uint32_t)
        mainloop_itr_time         : time the last mainloop iteration took (type:uint32_t)
        telecommand_cnt           : number of received and executed telecommands (type:uint8_t)
        state_cur                 : current System state (type:uint8_t)

        """
        return MAVLink_ejector_system_t_message(time_local, d2time, mainloop_itr_cnt, mainloop_itr_time, telecommand_cnt, state_cur)

    def ejector_system_t_send(self, time_local: int, d2time: int, mainloop_itr_cnt: int, mainloop_itr_time: int, telecommand_cnt: int, state_cur: int, force_mavlink1: bool = False) -> None:
        """
        Contains the whole Ejector system_t information + local time + state.

        time_local                : Ejector local time (type:int64_t)
        d2time                    : system time (type:uint32_t)
        mainloop_itr_cnt          : number of the current iteration of the mainloop (type:uint32_t)
        mainloop_itr_time         : time the last mainloop iteration took (type:uint32_t)
        telecommand_cnt           : number of received and executed telecommands (type:uint8_t)
        state_cur                 : current System state (type:uint8_t)

        """
        self.send(self.ejector_system_t_encode(time_local, d2time, mainloop_itr_cnt, mainloop_itr_time, telecommand_cnt, state_cur), force_mavlink1=force_mavlink1)

    def ejector_heartbeat_encode(self, time_local: int, d2time: int, telecommand_cnt: int, state_cur: int, led_enabled: int, cam_enabled: int, seed_power_enabled: int, seed_a_present: int, seed_b_present: int) -> MAVLink_ejector_heartbeat_message:
        """
        Contains information about the current state and local time.

        time_local                : Ejector local time (type:int64_t)
        d2time                    : system time (type:uint32_t)
        telecommand_cnt           : number of received and executed telecommands (type:uint8_t)
        state_cur                 : current System state (type:uint8_t)
        led_enabled               : LED status (type:uint8_t)
        cam_enabled               : Cam status (type:uint8_t)
        seed_power_enabled        : Seed Power status (type:uint8_t)
        seed_a_present            : presence of Seed A (type:uint8_t)
        seed_b_present            : presence of Seed B (type:uint8_t)

        """
        return MAVLink_ejector_heartbeat_message(time_local, d2time, telecommand_cnt, state_cur, led_enabled, cam_enabled, seed_power_enabled, seed_a_present, seed_b_present)

    def ejector_heartbeat_send(self, time_local: int, d2time: int, telecommand_cnt: int, state_cur: int, led_enabled: int, cam_enabled: int, seed_power_enabled: int, seed_a_present: int, seed_b_present: int, force_mavlink1: bool = False) -> None:
        """
        Contains information about the current state and local time.

        time_local                : Ejector local time (type:int64_t)
        d2time                    : system time (type:uint32_t)
        telecommand_cnt           : number of received and executed telecommands (type:uint8_t)
        state_cur                 : current System state (type:uint8_t)
        led_enabled               : LED status (type:uint8_t)
        cam_enabled               : Cam status (type:uint8_t)
        seed_power_enabled        : Seed Power status (type:uint8_t)
        seed_a_present            : presence of Seed A (type:uint8_t)
        seed_b_present            : presence of Seed B (type:uint8_t)

        """
        self.send(self.ejector_heartbeat_encode(time_local, d2time, telecommand_cnt, state_cur, led_enabled, cam_enabled, seed_power_enabled, seed_a_present, seed_b_present), force_mavlink1=force_mavlink1)
